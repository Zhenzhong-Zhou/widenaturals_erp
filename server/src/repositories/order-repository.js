const { query, paginateQuery } = require('../database/db');
const AppError = require('../utils/AppError');
const { logSystemException, logSystemInfo } = require('../utils/system-logger');
const { buildOrderFilter } = require('../utils/sql/build-order-filters');

/**
 * Inserts a new order record into the database.
 *
 * The `id` (UUID) and `order_number` must be pre-generated by the service layer
 * before calling this function. All required fields should be validated prior to insertion.
 *
 * @param {object} orderData - Full order payload for insertion.
 * @param {string} orderData.id - UUID of the order (must be generated in service layer).
 * @param {string} orderData.order_number - Unique, human-readable order number.
 * @param {string} orderData.order_type_id - Foreign key to `order_types` table.
 * @param {Date} orderData.order_date - The business date of the order.
 * @param {string} orderData.order_status_id - Foreign key to `order_status` table.
 * @param {Date} [orderData.status_date] - Status timestamp (defaults to now).
 * @param {object|null} [orderData.metadata] - Optional structured metadata (JSON).
 * @param {string|null} [orderData.note] - Optional internal note or comment.
 * @param {string|null} [orderData.shipping_address_id] - FK to `addresses` table (nullable).
 * @param {string|null} [orderData.billing_address_id] - FK to `addresses` table (nullable).
 * @param {string} orderData.created_by - User ID who created the order.
 * @param {string|null} [orderData.updated_by] - User ID for last update (optional).
 * @param {import('pg').PoolClient} client - PostgreSQL client with an active transaction context.
 *
 * @returns {Promise<string>} The ID of the newly inserted order.
 */
const insertOrder = async (orderData, client) => {
  const {
    id,
    order_number,
    order_type_id,
    order_date,
    order_status_id,
    note = null,
    shipping_address_id = null,
    billing_address_id = null,
    created_by,
    updated_at = null,
    updated_by = null,
  } = orderData;

  const insertOrderSQL = `
    INSERT INTO orders (
      id,
      order_number,
      order_type_id,
      order_date,
      order_status_id,
      note,
      shipping_address_id,
      billing_address_id,
      created_by,
      updated_at,
      updated_by
    )
    VALUES (
      $1, $2, $3, $4, $5, $6,
      $7, $8, $9, $10, $11
    )
    RETURNING id;
  `;

  const values = [
    id,
    order_number,
    order_type_id,
    order_date,
    order_status_id,
    note,
    shipping_address_id,
    billing_address_id,
    created_by,
    updated_at,
    updated_by,
  ];

  try {
    const { rows } = await query(insertOrderSQL, values, client);
    return rows[0]?.id;
  } catch (error) {
    logSystemException(
      error,
      'Database insert failed while creating a new order',
      {
        context: 'order-repository/insertOrder',
        payload: orderData,
      }
    );

    throw AppError.databaseError(
      'Database insert failed: could not create new order.'
    );
  }
};

/**
 * Fetches a paginated list of orders (e.g., sales orders) with optional filters, sorting, and joined metadata.
 *
 * Features:
 * - Applies dynamic filtering via `buildOrderFilter` (e.g., by status code, type ID, date ranges, etc.)
 * - Joins related tables for enriched metadata:
 *   - `order_types` → order type name
 *   - `order_status` → status code & name
 *   - `users` → createdBy / updatedBy usernames
 *   - `sales_orders` → sales-specific metadata
 *   - `customers`, `payment_methods`, `delivery_methods`, `payment_status`
 * - Adds `number_of_items` via subquery on `order_items`
 * - Supports pagination, sorting, and query tracing
 *
 * @async
 * @param {Object} options - Query options.
 * @param {OrderListFilters} [options.filters={}] - Filtering conditions (e.g., status code, type, created date).
 * @param {number} [options.page=1] - Page number for pagination.
 * @param {number} [options.limit=10] - Page size for pagination.
 * @param {string} [options.sortBy='created_at'] - Column name to sort by (e.g., 'order_date', 'status_date').
 * @param {'ASC' | 'DESC'} [options.sortOrder='DESC'] - Sort direction.
 * @returns {Promise<Object>} Paginated result including data and meta info.
 *
 * @example
 * const result = await getPaginatedOrders({
 *   filters: {
 *     orderStatusId: 'b6ef9f9f-23ab-4f13-a3e2-b8b62344c519',
 *     createdAfter: '2025-08-01T00:00:00Z',
 *   },
 *   page: 2,
 *   limit: 20,
 *   sortBy: 'order_date',
 *   sortOrder: 'ASC',
 * });
 */
const getPaginatedOrders =  async ({
                                     filters = {},
                                     page = 1,
                                     limit = 10,
                                     sortBy = 'created_at',
                                     sortOrder = 'DESC',
                                   }) => {
  const { whereClause, params } = buildOrderFilter(filters);
  
  const tableName = 'orders o';
  
  const joins = [
    'LEFT JOIN order_types ot ON o.order_type_id = ot.id',
    'LEFT JOIN order_status os ON o.order_status_id = os.id',
    'LEFT JOIN users u_created ON o.created_by = u_created.id',
    'LEFT JOIN users u_updated ON o.updated_by = u_updated.id',
    'LEFT JOIN sales_orders so ON so.id = o.id',
    'LEFT JOIN customers c ON so.customer_id = c.id',
    'LEFT JOIN payment_methods pm ON so.payment_method_id = pm.id',
    'LEFT JOIN delivery_methods dm ON so.delivery_method_id = dm.id',
    'LEFT JOIN payment_status ps ON so.payment_status_id = ps.id',
  ];
  
  const baseQuery = `
    SELECT
      o.id,
      o.order_number,
      ot.name AS order_type,
      os.code AS status_code,
      os.name AS status_name,
      o.order_date,
      o.status_date,
      o.created_at,
      u_created.firstname AS created_by_firstname,
      u_created.lastname AS created_by_lastname,
      o.updated_at,
      u_updated.firstname AS updated_by_firstname,
      u_updated.lastname AS updated_by_lastname,
      o.note,
      c.firstname AS customer_firstname,
      c.lastname AS customer_lastname,
      pm.name AS payment_method,
      ps.name AS payment_status,
      dm.method_name AS delivery_method,
      (
        SELECT COUNT(*)
        FROM order_items oi
        WHERE oi.order_id = o.id
      ) AS number_of_items
    FROM ${tableName}
    ${joins.join('\n')}
    WHERE ${whereClause}
  `;
  
  try {
    const result = await paginateQuery({
      tableName,
      joins,
      whereClause,
      queryText: baseQuery,
      params,
      page,
      limit,
      sortBy,
      sortOrder,
    });
    
    logSystemInfo('Fetched orders successfully', {
      context: 'order-repository/getPaginatedOrders',
      resultCount: result?.data?.length,
      filters,
      pagination: { page, limit },
      sorting: { sortBy, sortOrder },
    });
    
    return result;
  } catch (error) {
    logSystemException(error, 'Failed to fetch paginated orders', {
      context: 'order-repository/getPaginatedOrders',
      filters,
      page,
      limit,
      sortBy,
      sortOrder,
    });
    throw AppError.databaseError('Unable to fetch orders from the database', {
      cause: error,
      stage: 'get-paginated-orders',
    });
  }
};

/**
 * findOrderByIdWithDetails
 * ---------------------------------------
 * Repository: Fetch a single order header with human-readable details
 * (customer, payment, tax, discount, delivery, flattened shipping/billing address,
 * and created_by/updated_by names). Returns `null` if not found.
 *
 * Notes:
 * - This is a *header-only* query (no order_items). Pair it with a separate items query in the service layer.
 * - Safe, parameterized SQL with LIMIT 1.
 * - Repository returns raw DB row shape; service can transform/rename fields if needed.
 *
 * @param {string} orderId - UUID of the order (required)
 * @returns {Promise<object|null>} Single row object when found; otherwise `null`
 * @throws {AppError} AppError.databaseError on DB failure (connection, timeout, etc.)
 */
const findOrderByIdWithDetails = async (orderId) => {
  const sql = `
    SELECT
      o.id                         AS order_id,
      o.order_number,
      o.order_date,
      o.status_date,
      o.note,
      o.order_type_id,
      ot.name                      AS order_type_name,
      o.order_status_id,
      os.name                      AS order_status_name,
      os.code                      AS order_code,
      so.customer_id,
      c.firstname                  AS customer_firstname,
      c.lastname                   AS customer_lastname,
      (c.firstname || ' ' || c.lastname) AS customer_full_name,
      c.email                      AS customer_email,
      c.phone_number               AS customer_phone,
      so.payment_status_id,
      ps.name                      AS payment_status_name,
      so.payment_method_id,
      pmeth.name                   AS payment_method_name,
      so.currency_code,
      so.exchange_rate,
      so.base_currency_amount,
      so.discount_id,
      d.name                       AS discount_name,
      d.discount_type,
      d.discount_value,
      so.discount_amount,
      so.subtotal,
      so.tax_rate_id,
      tr.name                      AS tax_rate_name,
      tr.region                    AS tax_rate_region,
      tr.rate                      AS tax_rate_percent,
      tr.province                  AS tax_rate_province,
      so.tax_amount,
      so.shipping_fee,
      so.total_amount,
      so.delivery_method_id,
      dm.method_name               AS delivery_method_name,
      so.metadata                  AS sales_order_metadata,
      o.shipping_address_id,
      ship.customer_id             AS shipping_customer_id,
      ship.full_name               AS shipping_full_name,
      ship.phone                   AS shipping_phone,
      ship.email                   AS shipping_email,
      ship.label                   AS shipping_label,
      ship.address_line1           AS shipping_address_line1,
      ship.address_line2           AS shipping_address_line2,
      ship.city                    AS shipping_city,
      ship.state                   AS shipping_state,
      ship.postal_code             AS shipping_postal_code,
      ship.country                 AS shipping_country,
      ship.region                  AS shipping_region,
      o.billing_address_id,
      bill.customer_id             AS billing_customer_id,
      bill.full_name               AS billing_full_name,
      bill.phone                   AS billing_phone,
      bill.email                   AS billing_email,
      bill.label                   AS billing_label,
      bill.address_line1           AS billing_address_line1,
      bill.address_line2           AS billing_address_line2,
      bill.city                    AS billing_city,
      bill.state                   AS billing_state,
      bill.postal_code             AS billing_postal_code,
      bill.country                 AS billing_country,
      bill.region                  AS billing_region,
      o.created_at                 AS order_created_at,
      o.updated_at                 AS order_updated_at,
      o.created_by                 AS order_created_by,
      ucb.firstname AS order_created_by_firstname,
      ucb.lastname  AS order_created_by_lastname,
      o.updated_by                 AS order_updated_by,
      uub.firstname                AS order_updated_by_firstname,
      uub.lastname                 AS order_updated_by_lastname
    FROM orders o
    LEFT JOIN sales_orders        so    ON so.id = o.id
    LEFT JOIN order_types         ot    ON ot.id = o.order_type_id
    LEFT JOIN order_status        os    ON os.id = o.order_status_id
    LEFT JOIN customers           c     ON c.id = so.customer_id
    LEFT JOIN payment_status      ps    ON ps.id = so.payment_status_id
    LEFT JOIN payment_methods     pmeth ON pmeth.id = so.payment_method_id
    LEFT JOIN discounts           d     ON d.id = so.discount_id
    LEFT JOIN tax_rates           tr    ON tr.id = so.tax_rate_id
    LEFT JOIN delivery_methods    dm    ON dm.id = so.delivery_method_id
    LEFT JOIN addresses           ship  ON ship.id = o.shipping_address_id
    LEFT JOIN addresses           bill  ON bill.id = o.billing_address_id
    LEFT JOIN users               ucb   ON ucb.id = o.created_by
    LEFT JOIN users               uub   ON uub.id = o.updated_by
    WHERE o.id = $1;
  `;
  
  const logMeta = {
    context: 'order-repository/findOrderByIdWithDetails',
    severity: 'INFO',
    orderId,
    sqlTag: 'findOrderByIdWithDetails.v1',
  };
  
  try {
    const { rows } = await query(sql, [orderId]);
    
    if (rows.length === 0) {
      logSystemInfo('Order not found', { ...logMeta });
      return null;
    }
    
    logSystemInfo('Order fetched', { ...logMeta, rowCount: rows.length });
    return rows[0]; // header-only query should return a single row
  } catch (error) {
    // DB-level exception logging stays in repo; business decisions happen in service
    logSystemException('DB error fetching order', error, {
      ...logMeta,
      severity: 'ERROR',
    });
    
    // Hide DB internals from callers
    throw AppError.databaseError('Failed to fetch order details.');
  }
};

/**
 * Updates an order with new details, including metadata updates for manual price overrides.
 *
 * This function dynamically updates only the provided fields while preserving existing metadata.
 * It ensures that manual price overrides are properly tracked in `metadata` and prevents duplicate discount applications.
 *
 * @param {string} orderId - The unique identifier of the sales order to be updated.
 * @param {Object} updateData - The fields to update in the sales order.
 * @param {Array<Object>} [updateData.manual_price_overrides] - An array of manual price overrides to be appended to metadata.
 * @param {string} [updateData.discount_id] - The discount ID to apply to the order.
 * @param {number} [updateData.tax_amount] - The updated tax amount for the order.
 * @param {number} [updateData.total_amount] - The updated total amount for the order.
 * @param {string} [updateData.status_id] - The updated order status ID.
 * @param {string} [updateData.note] - Any additional notes related to the order.
 * @param {string} [updateData.updated_by] - The ID of the user making the update.
 * @param {Object} client - The database transaction client.
 * @returns {Promise<Object>} - The updated sales order record.
 * @throws {AppError} - Throws an error if the order is not found or if the update fails.
 */
const updateOrderData = async (orderId, updateData, client) => {
  try {
    // Step 1: Fetch the existing order metadata
    const existingOrder = await client.query(
      `SELECT metadata FROM orders WHERE id = $1`,
      [orderId]
    );

    if (!existingOrder.rows.length) {
      throw AppError.notFoundError(`Order ${orderId} not found.`);
    }

    let existingMetadata = existingOrder.rows[0].metadata || {};

    // Step 2: Merge metadata for manual price overrides
    if (updateData.manual_price_overrides) {
      existingMetadata.manual_price_overrides = [
        ...(existingMetadata.manual_price_overrides || []),
        ...updateData.manual_price_overrides,
      ];
    }

    // Step 3: Construct the update query dynamically
    let updateFields = [];
    let updateValues = [];
    let index = 1;

    if (updateData.discount_id) {
      updateFields.push(`discount_id = $${index}`);
      updateValues.push(updateData.discount_id);
      index++;
    }

    if (updateData.tax_amount !== undefined) {
      updateFields.push(`tax_amount = $${index}`);
      updateValues.push(updateData.tax_amount);
      index++;
    }

    if (updateData.total_amount !== undefined) {
      updateFields.push(`total_amount = $${index}`);
      updateValues.push(updateData.total_amount);
      index++;
    }

    if (updateData.status_id) {
      updateFields.push(`order_status_id = $${index}`);
      updateValues.push(updateData.status_id);
      index++;

      // If status changes, update status_date
      updateFields.push(`status_date = NOW()`);
    }

    if (updateData.note) {
      updateFields.push(`note = $${index}`);
      updateValues.push(updateData.note);
      index++;
    }

    // Always update metadata and timestamps
    updateFields.push(`metadata = $${index}`);
    updateValues.push(existingMetadata);
    index++;

    updateFields.push(`updated_at = NOW()`);

    if (updateData.updated_by) {
      updateFields.push(`updated_by = $${index}`);
      updateValues.push(updateData.updated_by);
      index++;
    }

    updateValues.push(orderId);

    const updateQuery = `
      UPDATE orders
      SET ${updateFields.join(', ')}
      WHERE id = $${index}
      RETURNING id;
    `;

    const updatedOrder = await client.query(updateQuery, updateValues);
    return updatedOrder.rows[0];
  } catch (error) {
    logError('Error updating order:', error);
    throw AppError.databaseError(`Failed to update order: ${error.message}`);
  }
};

/**
 * Fetches enriched order metadata, including status, type, and payment information.
 *
 * This function joins the `orders`, `sales_orders`, `order_types`, `order_status`,
 * and `payment_status` tables to return detailed information about the specified order.
 *
 * @param {string} orderId - UUID of the order to retrieve.
 * @param {object} client - Optional PostgreSQL client for transactional context.
 * @returns {Promise<object>} - Resolved order object containing status, type, and payment metadata.
 *
 * @throws {AppError} - If the order is not found or if the query execution fails.
 */
const fetchOrderMetadata = async (orderId, client) => {
  const sql = `
    SELECT
      o.id AS order_id,
      o.order_status_id,
      s.category AS order_status_category,
      s.code AS order_status_code,
      s.name AS order_status_name,
      o.order_type_id,
      ot.code AS order_type_code,
      ot.name AS order_type_name,
      ot.category AS order_category,
      ps.code AS payment_code
    FROM orders o
    JOIN sales_orders so ON o.id = so.id
    JOIN payment_status ps ON so.payment_status_id = ps.id
    JOIN order_types ot ON o.order_type_id = ot.id
    JOIN order_status s ON o.order_status_id = s.id
    WHERE o.id = $1
  `;
  
  try {
    const { rows } = await query(sql, [orderId], client);
    
    if (rows.length === 0) {
      throw AppError.notFoundError(`Order ${orderId} not found.`);
    }
    
    return rows[0];
  } catch (error) {
    logSystemException('Failed to fetch order metadata', {
      context: 'fetchOrderMetadata',
      orderId,
      error,
    });
    
    throw AppError.databaseError('Failed to retrieve order metadata.');
  }
};

/**
 * Updates the status of an order by setting a new status ID and timestamps.
 *
 * This function performs the following:
 * - Updates the `order_status_id`, `status_date`, `updated_at`, and `updated_by` fields
 *   in the `orders` table for the given `orderId`.
 * - Logs audit messages for success or failure.
 * - Returns the updated order record or `null` if no matching order was found.
 *
 * Typically used in controlled transitions such as confirming, fulfilling, or cancelling an order.
 *
 * @async
 * @param {object} client - An instance of a PostgreSQL client or transaction context (`pg.Client` or `pg.PoolClient`).
 * @param {object} params - Update parameters.
 * @param {string} params.orderId - UUID of the order to update.
 * @param {string} params.newStatusId - UUID of the new status to assign to the order.
 * @param {string} params.updatedBy - UUID of the user performing the update (used for audit).
 * @returns {Promise<{
 *   id: string,
 *   statusId: string,
 *   statusDate: string
 * } | null>} The updated order info if successful, or `null` if no matching order was found.
 *
 * @throws {AppError} If a database error occurs.
 */
const updateOrderStatus = async (client, { orderId, newStatusId, updatedBy }) => {
  const sql = `
    UPDATE orders
    SET
      order_status_id = $1,
      status_date = NOW(),
      updated_at = NOW(),
      updated_by = $2
    WHERE id = $3 AND order_status_id IS DISTINCT FROM $1
    RETURNING id, order_status_id, status_date
  `;
  
  const values = [newStatusId, updatedBy, orderId];
  
  try {
    const result = await query(sql, values, client);
    
    if (result.rowCount === 0) {
      logSystemInfo('Order status update skipped: no matching order', {
        context: 'order-repository/updateOrderStatus',
        orderId,
        newStatusId,
        updatedBy,
        severity: 'WARN',
      });
      return false;
    }
    
    const updatedOrder = result.rows[0];
    
    logSystemInfo('Order status updated successfully', {
      context: 'order-repository/updateOrderStatus',
      orderId: updatedOrder.id,
      newStatusId: updatedOrder.order_status_id,
      updatedBy,
      severity: 'INFO',
    });
    
    return updatedOrder;
  } catch (error) {
    logSystemException(error, 'Failed to update order status', {
      context: 'order-repository/updateOrderStatus',
      orderId,
      newStatusId,
      updatedBy,
      severity: 'ERROR',
    });
    
    throw AppError.databaseError(`Failed to update order status: ${error.message}`);
  }
};

/**
 * Fetches all inventory allocation records for a given order ID.
 *
 * Joins `orders`, `order_items`, and `inventory_allocations` to retrieve
 * allocation metadata for each item in the order, including:
 * - `allocation_id`: ID of the allocation record
 * - `order_item_id`: ID of the item in the order
 * - `warehouse_id`: Warehouse where the allocation is made
 * - `batch_id`: Batch being allocated
 * - `allocated_quantity`: Quantity allocated from the batch
 *
 * This is used for verifying allocation status and preparing inventory adjustments.
 *
 * @async
 * @function
 * @param {string} orderId - UUID of the target order.
 * @param {object} client - Database client or transaction context (e.g., from `withTransaction`).
 * @returns {Promise<Array<{
 *   allocation_id: string,
 *   order_item_id: string,
 *   warehouse_id: string,
 *   batch_id: string,
 *   allocated_quantity: number
 * }>>} - Array of allocation records for the given order.
 *
 * @throws {AppError} - Throws if a database query fails.
 */
const getInventoryAllocationsByOrderId = async (orderId, client) => {
  const sql = `
    SELECT
      ia.id AS allocation_id,
      ia.order_item_id,
      ia.warehouse_id,
      ia.batch_id,
      ia.allocated_quantity
    FROM orders o
    JOIN order_items oi ON oi.order_id = o.id
    JOIN inventory_allocations ia ON ia.order_item_id = oi.id
    WHERE o.id = $1;
  `;
  
  try {
    const result = await query(sql, [orderId], client);
    logSystemInfo('Order allocation details fetched', {
      context: 'order-repository/getInventoryAllocationsByOrderId',
      orderId,
      resultCount: result.rowCount,
      severity: 'INFO',
    });
    return result.rows;
  } catch (error) {
    logSystemException(error, 'Failed to fetch order allocation details', {
      context: 'order-repository/getInventoryAllocationsByOrderId',
      orderId,
    });
    throw AppError.databaseError('Error fetching order allocation details.');
  }
};

module.exports = {
  insertOrder,
  getPaginatedOrders,
  findOrderByIdWithDetails,
  updateOrderData,
  fetchOrderMetadata,
  updateOrderStatus,
  getInventoryAllocationsByOrderId,
};
