const { query, paginateQuery } = require('../database/db');
const AppError = require('../utils/AppError');
const { logSystemException, logSystemInfo } = require('../utils/system-logger');

const allocationEligibleStatuses = [
  'ORDER_CONFIRMED',
  'ORDER_ALLOCATING',
  'ORDER_ALLOCATED',
  'ORDER_PARTIAL',
];

/**
 * Inserts a new order record into the database.
 *
 * The `id` (UUID) and `order_number` must be pre-generated by the service layer
 * before calling this function. All required fields should be validated prior to insertion.
 *
 * @param {object} orderData - Full order payload for insertion.
 * @param {string} orderData.id - UUID of the order (must be generated in service layer).
 * @param {string} orderData.order_number - Unique, human-readable order number.
 * @param {string} orderData.order_type_id - Foreign key to `order_types` table.
 * @param {Date} orderData.order_date - The business date of the order.
 * @param {string} orderData.order_status_id - Foreign key to `order_status` table.
 * @param {Date} [orderData.status_date] - Status timestamp (defaults to now).
 * @param {object|null} [orderData.metadata] - Optional structured metadata (JSON).
 * @param {string|null} [orderData.note] - Optional internal note or comment.
 * @param {string|null} [orderData.shipping_address_id] - FK to `addresses` table (nullable).
 * @param {string|null} [orderData.billing_address_id] - FK to `addresses` table (nullable).
 * @param {string} orderData.created_by - User ID who created the order.
 * @param {string|null} [orderData.updated_by] - User ID for last update (optional).
 * @param {import('pg').PoolClient} client - PostgreSQL client with an active transaction context.
 *
 * @returns {Promise<string>} The ID of the newly inserted order.
 */
const insertOrder = async (orderData, client) => {
  const {
    id,
    order_number,
    order_type_id,
    order_date,
    order_status_id,
    note = null,
    shipping_address_id = null,
    billing_address_id = null,
    created_by,
    updated_at = null,
    updated_by = null,
  } = orderData;

  const insertOrderSQL = `
    INSERT INTO orders (
      id,
      order_number,
      order_type_id,
      order_date,
      order_status_id,
      note,
      shipping_address_id,
      billing_address_id,
      created_by,
      updated_at,
      updated_by
    )
    VALUES (
      $1, $2, $3, $4, $5, $6,
      $7, $8, $9, $10, $11
    )
    RETURNING id;
  `;

  const values = [
    id,
    order_number,
    order_type_id,
    order_date,
    order_status_id,
    note,
    shipping_address_id,
    billing_address_id,
    created_by,
    updated_at,
    updated_by,
  ];

  try {
    const { rows } = await query(insertOrderSQL, values, client);
    return rows[0]?.id;
  } catch (error) {
    logSystemException(
      error,
      'Database insert failed while creating a new order',
      {
        context: 'order-repository/insertOrder',
        payload: orderData,
      }
    );

    throw AppError.databaseError(
      'Database insert failed: could not create new order.'
    );
  }
};

/**
 * findOrderByIdWithDetails
 * ---------------------------------------
 * Repository: Fetch a single order header with human-readable details
 * (customer, payment, tax, discount, delivery, flattened shipping/billing address,
 * and created_by/updated_by names). Returns `null` if not found.
 *
 * Notes:
 * - This is a *header-only* query (no order_items). Pair it with a separate items query in the service layer.
 * - Safe, parameterized SQL with LIMIT 1.
 * - Repository returns raw DB row shape; service can transform/rename fields if needed.
 *
 * @param {string} orderId - UUID of the order (required)
 * @returns {Promise<object|null>} Single row object when found; otherwise `null`
 * @throws {AppError} AppError.databaseError on DB failure (connection, timeout, etc.)
 */
const findOrderByIdWithDetails = async (orderId) => {
  const sql = `
    SELECT
      o.id                         AS order_id,
      o.order_number,
      o.order_date,
      o.status_date,
      o.note,
      o.order_type_id,
      ot.name                      AS order_type_name,
      o.order_status_id,
      os.name                      AS order_status_name,
      os.code                      AS order_code,
      so.customer_id,
      c.firstname                  AS customer_firstname,
      c.lastname                   AS customer_lastname,
      (c.firstname || ' ' || c.lastname) AS customer_full_name,
      c.email                      AS customer_email,
      c.phone_number               AS customer_phone,
      so.payment_status_id,
      ps.name                      AS payment_status_name,
      so.payment_method_id,
      pmeth.name                   AS payment_method_name,
      so.currency_code,
      so.exchange_rate,
      so.base_currency_amount,
      so.discount_id,
      d.name                       AS discount_name,
      d.discount_type,
      d.discount_value,
      so.discount_amount,
      so.subtotal,
      so.tax_rate_id,
      tr.name                      AS tax_rate_name,
      tr.region                    AS tax_rate_region,
      tr.rate                      AS tax_rate_percent,
      tr.province                  AS tax_rate_province,
      so.tax_amount,
      so.shipping_fee,
      so.total_amount,
      so.delivery_method_id,
      dm.method_name               AS delivery_method_name,
      so.metadata                  AS sales_order_metadata,
      o.shipping_address_id,
      ship.customer_id             AS shipping_customer_id,
      ship.full_name               AS shipping_full_name,
      ship.phone                   AS shipping_phone,
      ship.email                   AS shipping_email,
      ship.label                   AS shipping_label,
      ship.address_line1           AS shipping_address_line1,
      ship.address_line2           AS shipping_address_line2,
      ship.city                    AS shipping_city,
      ship.state                   AS shipping_state,
      ship.postal_code             AS shipping_postal_code,
      ship.country                 AS shipping_country,
      ship.region                  AS shipping_region,
      o.billing_address_id,
      bill.customer_id             AS billing_customer_id,
      bill.full_name               AS billing_full_name,
      bill.phone                   AS billing_phone,
      bill.email                   AS billing_email,
      bill.label                   AS billing_label,
      bill.address_line1           AS billing_address_line1,
      bill.address_line2           AS billing_address_line2,
      bill.city                    AS billing_city,
      bill.state                   AS billing_state,
      bill.postal_code             AS billing_postal_code,
      bill.country                 AS billing_country,
      bill.region                  AS billing_region,
      o.created_at                 AS order_created_at,
      o.updated_at                 AS order_updated_at,
      o.created_by                 AS order_created_by,
      ucb.firstname AS order_created_by_firstname,
      ucb.lastname  AS order_created_by_lastname,
      o.updated_by                 AS order_updated_by,
      uub.firstname                AS order_updated_by_firstname,
      uub.lastname                 AS order_updated_by_lastname
    FROM orders o
    LEFT JOIN sales_orders        so    ON so.id = o.id
    LEFT JOIN order_types         ot    ON ot.id = o.order_type_id
    LEFT JOIN order_status        os    ON os.id = o.order_status_id
    LEFT JOIN customers           c     ON c.id = so.customer_id
    LEFT JOIN payment_status      ps    ON ps.id = so.payment_status_id
    LEFT JOIN payment_methods     pmeth ON pmeth.id = so.payment_method_id
    LEFT JOIN discounts           d     ON d.id = so.discount_id
    LEFT JOIN tax_rates           tr    ON tr.id = so.tax_rate_id
    LEFT JOIN delivery_methods    dm    ON dm.id = so.delivery_method_id
    LEFT JOIN addresses           ship  ON ship.id = o.shipping_address_id
    LEFT JOIN addresses           bill  ON bill.id = o.billing_address_id
    LEFT JOIN users               ucb   ON ucb.id = o.created_by
    LEFT JOIN users               uub   ON uub.id = o.updated_by
    WHERE o.id = $1;
  `;
  
  const logMeta = {
    context: 'order-repository/findOrderByIdWithDetails',
    severity: 'INFO',
    orderId,
    sqlTag: 'findOrderByIdWithDetails.v1',
  };
  
  try {
    const { rows } = await query(sql, [orderId]);
    
    if (rows.length === 0) {
      logSystemInfo('Order not found', { ...logMeta });
      return null;
    }
    
    logSystemInfo('Order fetched', { ...logMeta, rowCount: rows.length });
    return rows[0]; // header-only query should return a single row
  } catch (error) {
    // DB-level exception logging stays in repo; business decisions happen in service
    logSystemException('DB error fetching order', error, {
      ...logMeta,
      severity: 'ERROR',
    });
    
    // Hide DB internals from callers
    throw AppError.databaseError('Failed to fetch order details.');
  }
};

/**
 * Updates an order with new details, including metadata updates for manual price overrides.
 *
 * This function dynamically updates only the provided fields while preserving existing metadata.
 * It ensures that manual price overrides are properly tracked in `metadata` and prevents duplicate discount applications.
 *
 * @param {string} orderId - The unique identifier of the sales order to be updated.
 * @param {Object} updateData - The fields to update in the sales order.
 * @param {Array<Object>} [updateData.manual_price_overrides] - An array of manual price overrides to be appended to metadata.
 * @param {string} [updateData.discount_id] - The discount ID to apply to the order.
 * @param {number} [updateData.tax_amount] - The updated tax amount for the order.
 * @param {number} [updateData.total_amount] - The updated total amount for the order.
 * @param {string} [updateData.status_id] - The updated order status ID.
 * @param {string} [updateData.note] - Any additional notes related to the order.
 * @param {string} [updateData.updated_by] - The ID of the user making the update.
 * @param {Object} client - The database transaction client.
 * @returns {Promise<Object>} - The updated sales order record.
 * @throws {AppError} - Throws an error if the order is not found or if the update fails.
 */
const updateOrderData = async (orderId, updateData, client) => {
  try {
    // Step 1: Fetch the existing order metadata
    const existingOrder = await client.query(
      `SELECT metadata FROM orders WHERE id = $1`,
      [orderId]
    );

    if (!existingOrder.rows.length) {
      throw AppError.notFoundError(`Order ${orderId} not found.`);
    }

    let existingMetadata = existingOrder.rows[0].metadata || {};

    // Step 2: Merge metadata for manual price overrides
    if (updateData.manual_price_overrides) {
      existingMetadata.manual_price_overrides = [
        ...(existingMetadata.manual_price_overrides || []),
        ...updateData.manual_price_overrides,
      ];
    }

    // Step 3: Construct the update query dynamically
    let updateFields = [];
    let updateValues = [];
    let index = 1;

    if (updateData.discount_id) {
      updateFields.push(`discount_id = $${index}`);
      updateValues.push(updateData.discount_id);
      index++;
    }

    if (updateData.tax_amount !== undefined) {
      updateFields.push(`tax_amount = $${index}`);
      updateValues.push(updateData.tax_amount);
      index++;
    }

    if (updateData.total_amount !== undefined) {
      updateFields.push(`total_amount = $${index}`);
      updateValues.push(updateData.total_amount);
      index++;
    }

    if (updateData.status_id) {
      updateFields.push(`order_status_id = $${index}`);
      updateValues.push(updateData.status_id);
      index++;

      // If status changes, update status_date
      updateFields.push(`status_date = NOW()`);
    }

    if (updateData.note) {
      updateFields.push(`note = $${index}`);
      updateValues.push(updateData.note);
      index++;
    }

    // Always update metadata and timestamps
    updateFields.push(`metadata = $${index}`);
    updateValues.push(existingMetadata);
    index++;

    updateFields.push(`updated_at = NOW()`);

    if (updateData.updated_by) {
      updateFields.push(`updated_by = $${index}`);
      updateValues.push(updateData.updated_by);
      index++;
    }

    updateValues.push(orderId);

    const updateQuery = `
      UPDATE orders
      SET ${updateFields.join(', ')}
      WHERE id = $${index}
      RETURNING id;
    `;

    const updatedOrder = await client.query(updateQuery, updateValues);
    return updatedOrder.rows[0];
  } catch (error) {
    logError('Error updating order:', error);
    throw AppError.databaseError(`Failed to update order: ${error.message}`);
  }
};

/**
 * Fetches enriched order metadata, including status, type, and payment information.
 *
 * This function joins the `orders`, `sales_orders`, `order_types`, `order_status`,
 * and `payment_status` tables to return detailed information about the specified order.
 *
 * @param {string} orderId - UUID of the order to retrieve.
 * @param {object} client - Optional PostgreSQL client for transactional context.
 * @returns {Promise<object>} - Resolved order object containing status, type, and payment metadata.
 *
 * @throws {AppError} - If the order is not found or if the query execution fails.
 */
const fetchOrderMetadata = async (orderId, client) => {
  const sql = `
    SELECT
      o.id AS order_id,
      o.order_status_id,
      s.category AS order_status_category,
      s.code AS order_status_code,
      s.name AS order_status_name,
      o.order_type_id,
      ot.code AS order_type_code,
      ot.name AS order_type_name,
      ot.category AS order_category,
      ps.code AS payment_code
    FROM orders o
    JOIN sales_orders so ON o.id = so.id
    JOIN payment_status ps ON so.payment_status_id = ps.id
    JOIN order_types ot ON o.order_type_id = ot.id
    JOIN order_status s ON o.order_status_id = s.id
    WHERE o.id = $1
  `;
  
  try {
    const { rows } = await query(sql, [orderId], client);
    
    if (rows.length === 0) {
      throw AppError.notFoundError(`Order ${orderId} not found.`);
    }
    
    return rows[0];
  } catch (error) {
    logSystemException('Failed to fetch order metadata', {
      context: 'fetchOrderMetadata',
      orderId,
      error,
    });
    
    throw AppError.databaseError('Failed to retrieve order metadata.');
  }
};

/**
 * Updates the status of an order by setting a new status ID and timestamps.
 *
 * This function performs the following:
 * - Updates the `order_status_id`, `status_date`, `updated_at`, and `updated_by` fields
 *   in the `orders` table for the given `orderId`.
 * - Logs audit messages for success or failure.
 * - Returns the updated order record or `null` if no matching order was found.
 *
 * Typically used in controlled transitions such as confirming, fulfilling, or cancelling an order.
 *
 * @async
 * @param {object} client - An instance of a PostgreSQL client or transaction context (`pg.Client` or `pg.PoolClient`).
 * @param {object} params - Update parameters.
 * @param {string} params.orderId - UUID of the order to update.
 * @param {string} params.newStatusId - UUID of the new status to assign to the order.
 * @param {string} params.updatedBy - UUID of the user performing the update (used for audit).
 * @returns {Promise<{
 *   id: string,
 *   statusId: string,
 *   statusDate: string
 * } | null>} The updated order info if successful, or `null` if no matching order was found.
 *
 * @throws {AppError} If a database error occurs.
 */
const updateOrderStatus = async (client, { orderId, newStatusId, updatedBy }) => {
  const sql = `
    UPDATE orders
    SET
      order_status_id = $1,
      status_date = NOW(),
      updated_at = NOW(),
      updated_by = $2
    WHERE id = $3 AND order_status_id IS DISTINCT FROM $1
    RETURNING id, order_status_id, status_date
  `;
  
  const values = [newStatusId, updatedBy, orderId];
  
  try {
    const result = await query(sql, values, client);
    
    if (result.rowCount === 0) {
      logSystemInfo('Order status update skipped: no matching order', {
        context: 'order-repository/updateOrderStatus',
        orderId,
        newStatusId,
        updatedBy,
        severity: 'WARN',
      });
      return false;
    }
    
    const updatedOrder = result.rows[0];
    
    logSystemInfo('Order status updated successfully', {
      context: 'order-repository/updateOrderStatus',
      orderId: updatedOrder.id,
      newStatusId: updatedOrder.order_status_id,
      updatedBy,
      severity: 'INFO',
    });
    
    return updatedOrder;
  } catch (error) {
    logSystemException(error, 'Failed to update order status', {
      context: 'order-repository/updateOrderStatus',
      orderId,
      newStatusId,
      updatedBy,
      severity: 'ERROR',
    });
    
    throw AppError.databaseError(`Failed to update order status: ${error.message}`);
  }
};

/**
 * Shared logic for fetching orders with pagination, sorting, and optional filters.
 *
 * @param {Object} options - Query options for fetching orders.
 * @param {number} [options.page=1] - Page number for pagination.
 * @param {number} [options.limit=10] - Number of records per page.
 * @param {string} [options.sortBy='created_at'] - Column to sort by.
 * @param {string} [options.sortOrder='DESC'] - Sort order ('ASC' or 'DESC').
 * @param {string} [options.extraWhereClause=''] - Optional extra WHERE condition to apply.
 * @returns {Promise<Object>} - Paginated result of orders.
 * @throws {AppError} - Throws a database error if query fails.
 */
const getOrdersWithFilters = async ({
  page = 1,
  limit = 10,
  sortBy = 'created_at',
  sortOrder = 'DESC',
  extraWhereClause = '',
} = {}) => {
  const tableName = 'orders o';
  const joins = [
    'JOIN order_types ot ON o.order_type_id = ot.id',
    'JOIN order_status os ON o.order_status_id = os.id',
    'LEFT JOIN users u1 ON o.created_by = u1.id',
    'LEFT JOIN users u2 ON o.updated_by = u2.id',
  ];

  const allowedSortFields = [
    'order_number',
    'category',
    'name',
    'order_date',
    'created_at',
    'updated_at',
  ];

  const validatedSortBy = allowedSortFields.includes(sortBy)
    ? `o.${sortBy}`
    : 'o.created_at';

  const whereClause = ['1=1'];
  if (extraWhereClause) {
    whereClause.push(extraWhereClause);
  }

  const baseQuery = `
    SELECT
      o.id,
      o.order_number,
      ot.name AS order_type,
      o.order_date,
      os.name AS status,
      os.code AS status_code,
      o.created_at,
      o.updated_at,
      o.note,
      COALESCE(u1.firstname || ' ' || u1.lastname, 'Unknown') AS created_by,
      COALESCE(u2.firstname || ' ' || u2.lastname, 'Unknown') AS updated_by
    FROM ${tableName}
    ${joins.join(' ')}
    WHERE ${whereClause.join(' AND ')}
  `;

  try {
    return await retry(
      () =>
        paginateQuery({
          tableName,
          joins,
          whereClause: whereClause.join(' AND '),
          queryText: baseQuery,
          params: [],
          page,
          limit,
          sortBy: validatedSortBy,
          sortOrder,
        }),
      3
    );
  } catch (error) {
    logError('Error fetching orders:', error);
    throw AppError.databaseError('Failed to fetch orders');
  }
};

/**
 * Fetches all orders with pagination, sorting, and order number verification.
 * Applies retry logic for robustness.
 *
 * @param {Object} options - Fetch options for the query.
 * @param {number} options.page - The current page number (default: 1).
 * @param {number} options.limit - The number of orders per page (default: 10).
 * @param {string} options.sortBy - The column to sort the results by (default: 'created_at').
 * @param {string} options.sortOrder - The order of sorting ('ASC' or 'DESC', default: 'DESC').
 * @returns {Promise<Object>} - The paginated orders result.
 * @throws {AppError} - If the query fails or verification fails.
 */
const getAllOrders = (options = {}) => {
  return getOrdersWithFilters(options);
};

/**
 * Fetches orders eligible for inventory allocation (based on status codes).
 *
 * @param {Object} options - Query options for fetching orders.
 * @param {number} [options.page=1] - Page number for pagination.
 * @param {number} [options.limit=10] - Number of records per page.
 * @param {string} [options.sortBy='created_at'] - Column to sort by.
 * @param {string} [options.sortOrder='DESC'] - Sort order ('ASC' or 'DESC').
 * @returns {Promise<Object>} - Paginated result of allocation-eligible orders.
 */
const getAllocationEligibleOrders = (options = {}) => {
  return getOrdersWithFilters({
    ...options,
    extraWhereClause: `os.code = ANY(ARRAY['${allocationEligibleStatuses.join("','")}'])`,
  });
};

/**
 * Fetches the order status and all associated items by order ID.
 * Used for validation and inventory allocation preparation.
 *
 * @param {string} orderId - The UUID of the order.
 * @param {import('pg').PoolClient} [client] - Optional PostgreSQL client for transactional execution.
 * @returns {Promise<{order_id: string, order_status_id: string, order_status_name: string, items: {inventory_id: string, quantity_ordered: number}[]}>}
 * @throws {AppError} - If the order is not found or has no items.
 */
const getOrderStatusAndItems = async (orderId, client) => {
  const sql = `
    SELECT
      o.order_number,
      o.order_status_id,
      os.code AS order_status_code,
      oi.id AS order_item_id,
      oi.inventory_id,
      oi.quantity_ordered,
      oi.status_id AS order_item_status_id,
      ios.code AS order_item_status_code
    FROM orders o
    JOIN order_status os ON o.order_status_id = os.id
    JOIN order_items oi ON oi.order_id = o.id
    JOIN inventory i ON oi.inventory_id = i.id
    JOIN order_status ios ON oi.status_id = ios.id
    WHERE o.id = $1
  `;

  try {
    const result = await query(sql, [orderId], client);

    if (!result.rows || result.rows.length === 0) {
      return null;
    }

    return result.rows;
  } catch (error) {
    logError('Error fetching order and items:', error);
    throw AppError.databaseError(
      'Failed to fetch order and items: ' + error.message
    );
  }
};

/**
 * Retrieves the order status code and the status codes of all related order items
 * for a given order ID. Returns one row per order item.
 *
 * Useful for validation logic before confirming an order (e.g., ensuring all items
 * are in a confirmable status like `ITEM_PENDING`).
 *
 * @param {string} orderId - The UUID of the order to fetch status codes for.
 * @param {object} client - The PostgreSQL transaction client.
 * @returns {Promise<Array<{ order_status_code: string, order_item_status_code: string }> | null>}
 *          An array of status code objects for the order and each item,
 *          or `null` if no matching order is found.
 * @throws {AppError} - Throws a database error if the query fails.
 */
const getOrderAndItemStatusCodes = async (orderId, client) => {
  const sql = `
    SELECT
      os.code AS order_status_code,
      ios.code AS order_item_status_code
    FROM orders o
    JOIN order_status os ON o.order_status_id = os.id
    JOIN order_items oi ON oi.order_id = o.id
    JOIN order_status ios ON oi.status_id = ios.id
    WHERE o.id = $1
  `;

  try {
    const result = await retry(() => query(sql, [orderId], client));

    if (!result.rows || result.rows.length === 0) {
      return null;
    }

    return result.rows; // array of status codes (for each order item)
  } catch (error) {
    logError('Error fetching order/item status codes:', error);
    throw AppError.databaseError(
      'Failed to fetch status codes: ' + error.message
    );
  }
};

/**
 * Fetches all inventory allocation records for a given order ID.
 *
 * Joins `orders`, `order_items`, and `inventory_allocations` to retrieve
 * allocation metadata for each item in the order, including:
 * - `allocation_id`: ID of the allocation record
 * - `order_item_id`: ID of the item in the order
 * - `warehouse_id`: Warehouse where the allocation is made
 * - `batch_id`: Batch being allocated
 * - `allocated_quantity`: Quantity allocated from the batch
 *
 * This is used for verifying allocation status and preparing inventory adjustments.
 *
 * @async
 * @function
 * @param {string} orderId - UUID of the target order.
 * @param {object} client - Database client or transaction context (e.g., from `withTransaction`).
 * @returns {Promise<Array<{
 *   allocation_id: string,
 *   order_item_id: string,
 *   warehouse_id: string,
 *   batch_id: string,
 *   allocated_quantity: number
 * }>>} - Array of allocation records for the given order.
 *
 * @throws {AppError} - Throws if a database query fails.
 */
const getInventoryAllocationsByOrderId = async (orderId, client) => {
  const sql = `
    SELECT
      ia.id AS allocation_id,
      ia.order_item_id,
      ia.warehouse_id,
      ia.batch_id,
      ia.allocated_quantity
    FROM orders o
    JOIN order_items oi ON oi.order_id = o.id
    JOIN inventory_allocations ia ON ia.order_item_id = oi.id
    WHERE o.id = $1;
  `;
  
  try {
    const result = await query(sql, [orderId], client);
    logSystemInfo('Order allocation details fetched', {
      context: 'order-repository/getInventoryAllocationsByOrderId',
      orderId,
      resultCount: result.rowCount,
      severity: 'INFO',
    });
    return result.rows;
  } catch (error) {
    logSystemException(error, 'Failed to fetch order allocation details', {
      context: 'order-repository/getInventoryAllocationsByOrderId',
      orderId,
    });
    throw AppError.databaseError('Error fetching order allocation details.');
  }
};

module.exports = {
  insertOrder,
  findOrderByIdWithDetails,
  updateOrderData,
  fetchOrderMetadata,
  updateOrderStatus,
  getAllOrders,
  getAllocationEligibleOrders,
  getOrderStatusAndItems,
  getOrderAndItemStatusCodes,
  getInventoryAllocationsByOrderId,
};
